[
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "title": "Take-home_Ex02",
    "section": "",
    "text": "pacman::p_load(jsonlite, tidyverse, tidygraph, ggraph, visNetwork, lubridate, igraph, ggplot2, dplyr, magrittr)\n\n\n\n\n\nmc2_data <- fromJSON(\"C:/Fay1109/ISSS608-VAA/Take-home_Ex/Take-home_Ex02/data/mc2_challenge_graph.json\")\n\n\n\n\n\n\nThe code chunk is used to extract nodes/edges data tables from MC2 list object and save the output in a tibble data frame object called MC2_nodes and MC2_edges.\n\nmc2_nodes <- as_tibble(mc2_data$nodes) %>%\n  select(id, shpcountry, rcvcountry)\n\n\nmc2_edges <- as_tibble(mc2_data$links) %>%\n  mutate(ArrivalDate = ymd(arrivaldate)) %>%\n  mutate(Year = year(ArrivalDate)) %>%\n  select(source, target, ArrivalDate, Year, hscode, valueofgoods_omu, \n         volumeteu, weightkg, valueofgoodsusd) %>% \n  distinct()\n\nMap hscode to corresponding fish type.\n\nmc2_edges_mapped <- mc2_edges %>%\n  mutate(fishtype = case_when(\n    startsWith(hscode, \"301\") ~ \"live fish\",\n    startsWith(hscode, \"302\") ~ \"fresh fish\",\n    startsWith(hscode, \"303\") ~ \"frozen fish\",\n    startsWith(hscode, \"304\") ~ \"fish meat\",\n    startsWith(hscode, \"305\") ~ \"processed fish\",\n    startsWith(hscode, \"306\") ~ \"crustaceans\",  #like lobster or shrimps\n    startsWith(hscode, \"307\") ~ \"molluscs\",  #like Oysters or Abalone\n    startsWith(hscode, \"308\") ~ \"aquatic invertebrates\", #like Sea cucumbers?\n    startsWith(hscode, \"309\") ~ \"seafood flours\",  #fish powder, shrimp powder?\n    TRUE ~ \"not fish\"\n  ))\n\nVisualization\nThe graph below shows the number of counts in different fish categories being traded along the time. Fish meat is transported with the most frequent times in each year, followed by crustaceans\n\nlibrary(ggplot2)\n\n# Group the data by fishtype and Year and calculate the count\nfish_counts <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(count = n())\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Plot the graph\nggplot(fish_counts, aes(x = Year, y = count, fill = fishtype)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(x = \"Year\", y = \"Count\", fill = \"Fish Category\") +\n  scale_fill_discrete(name = \"Fish Category\") +\n  scale_y_continuous(labels = function(x) format(x, big.mark = \",\")) +\n  theme_minimal()\n\n\n\n\nThis is the graph showing the distribution of number of companies shipping different types of products. It can be seen that fish meat is shipped by most companies, followed by frozen fish. Live fish and aquatic invertebrates are the least two product categories shipped by companies.\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(magrittr)\n# Filter out the \"not fish\" category\nfiltered_data <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  distinct(source, fishtype)\n\n# Group the data by fishtype and calculate the number of unique companies\nfish_counts <- filtered_data %>%\n  group_by(fishtype) %>%\n  summarise(count = n_distinct(source))\n\n# Plot the bar chart\nggplot(fish_counts, aes(x = fishtype, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(x = \"Fish Type\", y = \"Number of Companies\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\nHere is the line chart to show the changes of shipments in different fish types. It can be seen that live fish and processed fish does not change too much in number of shipments. Fish meat and molluscs have some fluctuations in number of shipments and have a decreasing trend from 2033 to 2034. Frozen fish and crustaceans have an increasing trend in number of shipments.\n\nlibrary(ggplot2)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n# Filter out the \"not fish\" category\nfish_counts <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(total_count = n())\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Plot the line chart\nggplot(fish_counts, aes(x = Year, y = total_count, color = fishtype, group = fishtype)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Number of Shipments\", color = \"Fish Category\") +\n  scale_color_discrete(name = \"Fish Category\") +\n  theme_minimal() +\n  theme(legend.position = \"right\") +\n  scale_y_continuous(labels = comma)\n\n\n\n\nThe line chart below shows the total weight of all categories shipped along these years. It can be seen from the graph that total weights of shipment has an increasing trend from the first year to 2032. Then it has a decreasing trend after 2032. One interesting finding is that most shipment reach the peak value of total weights in quarter 3.\n\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(scales)\nlibrary(plotly)\n\nWarning: package 'plotly' was built under R version 4.2.3\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\n# Convert ArrivalDate to a date object\nmc2_edges_mapped$ArrivalDate <- ymd(mc2_edges_mapped$ArrivalDate)\n\n# Extract Year and Quarter from ArrivalDate\nmc2_edges_mapped$Year <- year(mc2_edges_mapped$ArrivalDate)\nmc2_edges_mapped$Quarter <- quarter(mc2_edges_mapped$ArrivalDate)\n\n# Group the data by Year and Quarter and calculate the total weightkg\nweight_by_quarter <- mc2_edges_mapped %>%\n  group_by(Year, Quarter) %>%\n  summarise(total_weight = sum(weightkg))\n\n`summarise()` has grouped output by 'Year'. You can override using the\n`.groups` argument.\n\n# Create a combined Year-Quarter label\nweight_by_quarter$YearQuarter <- paste(weight_by_quarter$Year, weight_by_quarter$Quarter, sep = \", \")\n\n# Get the unique years\nunique_years <- unique(weight_by_quarter$Year)\n\n# Plot the line graph with modified x-axis labels\np <- ggplot(weight_by_quarter, aes(x = YearQuarter, y = total_weight, group = 1)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Weight (kg)\") +\n  theme_minimal() +\n  scale_x_discrete(labels = function(x) {\n    ifelse(grepl(\", 1\", x), c(gsub(\",.*\", \"\", x), unique_years[match(gsub(\",.*\", \"\", x), unique_years)]), \"\")\n  }, expand = c(0, 0)) +\n  scale_y_continuous(labels = scales::comma, limits = c(0, max(weight_by_quarter$total_weight) * 1.1), expand = c(0, 0))\n\n# Convert the ggplot object to plotly\np <- ggplotly(p, tooltip = c(\"x\", \"y\"))\n\n# Display the interactive plot\np\n\n\n\n\n\nThis is the line showing the change in total weights of shipment in different fish types. The trend of line in each fish type is very similar to the line plotting the number of shipments in each fish type, which is quite reasonable.\n\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(scales)\nlibrary(plotly)\n\n# Convert ArrivalDate to a date object\nmc2_edges_mapped$ArrivalDate <- ymd(mc2_edges_mapped$ArrivalDate)\n\n# Extract Year and Quarter from ArrivalDate\nmc2_edges_mapped$Year <- year(mc2_edges_mapped$ArrivalDate)\nmc2_edges_mapped$Quarter <- quarter(mc2_edges_mapped$ArrivalDate)\n\n# Filter out the \"not fish\" category\nfish_weights <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(total_weight = sum(weightkg))\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Create a combined Year-Quarter label\nfish_weights$YearQuarter <- paste(fish_weights$Year, fish_weights$Quarter, sep = \", \")\n\nWarning: Unknown or uninitialised column: `Quarter`.\n\n# Plot the line chart\np <- ggplot(fish_weights, aes(x = YearQuarter, y = total_weight, color = fishtype, group = fishtype)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Weight (kg)\", color = \"Fish Category\") +\n  scale_color_discrete(name = \"Fish Category\") +\n  theme_minimal() +\n  theme(legend.position = \"right\") +\n  scale_y_continuous(labels = comma)\n\n# Convert the ggplot object to plotly\np <- ggplotly(p, tooltip = c(\"x\", \"y\"))\n\n# Display the interactive plot\np\n\n\n\n\n\n\nmc2_edges_aggregated <- mc2_edges_mapped %>%\n  filter(fishtype != \"no fish\") %>%\n  mutate(Year = as.character(Year), Quarter = as.character(Quarter)) %>%\n  filter((Year == \"2032\" & Quarter == \"3\") | (Year != \"2032\")) %>%\n  group_by(source, target, fishtype, Year) %>%\n  summarise(weights = n()) %>%\n  filter(source != target) %>%\n  filter(weights > 20) %>%\n  ungroup()\n\n`summarise()` has grouped output by 'source', 'target', 'fishtype'. You can\noverride using the `.groups` argument.\n\n\n\nid1 <- mc2_edges_aggregated %>%\n  select(source) %>%\n  rename(id = source)\nid2 <- mc2_edges_aggregated %>%\n  select(target) %>%\n  rename(id = target)\nmc2_nodes_extracted <- rbind(id1, id2) %>%\n  distinct()\n\n\nmc2_graph <- tbl_graph(nodes = mc2_nodes_extracted,\n                       edges = mc2_edges_aggregated,\n                       directed = TRUE)\n\n\nggraph(mc2_graph,\n       layout = \"fr\") +\n  geom_edge_link(aes()) +\n  geom_node_point(aes()) +\n  theme_graph()\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\nedges_df <- mc2_graph %>%\n  activate(edges) %>%\n  as.tibble()\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\n\n\nwrite_rds(mc2_nodes_extracted, \"data/mc2_nodes_extracted.rds\")\nwrite_rds(mc2_edges_aggregated, \"data/mc2_edges_aggregated.rds\")\nwrite_rds(mc2_graph, \"data/mc2_graph.rds\")\n\n\nmc2_graph\n\n# A tbl_graph: 6664 nodes and 35991 edges\n#\n# A directed multigraph with 104 components\n#\n# A tibble: 6,664 × 1\n  id                                          \n  <chr>                                       \n1 \" Direct Limited Liability Company Shipping\"\n2 \" Direct S.A. de C.V.\"                      \n3 \" Direct Shark Oyj Marine sanctuary\"        \n4 \"-28\"                                       \n5 \"-64\"                                       \n6 \"1 AS Marine sanctuary\"                     \n# ℹ 6,658 more rows\n#\n# A tibble: 35,991 × 5\n   from    to fishtype Year  weights\n  <int> <int> <chr>    <chr>   <int>\n1     1  3848 not fish 2028       25\n2     1  3848 not fish 2029       28\n3     2  3849 not fish 2033       35\n# ℹ 35,988 more rows\n\n\n\nedges_df <- mc2_graph %>%\n  activate(edges) %>%\n  as.tibble()\n\n\nnodes_df <- mc2_graph %>%\n  activate(nodes) %>%\n  as_tibble() %>%\n  rename(label = id) %>%\n  mutate(id = row_number())\n\nThe network below shows the interaction between shipping and receiving countries. The graph represents various nodes (representing entities such as countries or regions) and edges (representing trade connections). visNetwork function is used to create the graph, with the nodes and edges as input. The layout of the graph is determined by the “layout_with_fr” option, which utilizes the Fruchterman-Reingold algorithm. The edges are displayed with curved arrows for visual clarity.\n\nlibrary(visNetwork)\nlibrary(igraph)\n\n# Create the graph from the data frame\ngraph <- graph_from_data_frame(mc2_edges, directed = FALSE)\n\n# Calculate the number of edges for each node (node degrees)\nnode_degrees <- degree(graph)\n\n# Sort the nodes based on the number of edges in descending order\nsorted_nodes <- nodes_df[order(-node_degrees), ]\n\n# Get the top 20 nodes\ntop_twenty_nodes <- sorted_nodes[1:20, ]\n\n# Create the visNetwork graph\nvisNetwork(nodes_df, edges_df, main = \"FishEye Trade Network\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visEdges(arrows = \"to\", smooth = list(enabled = TRUE, type = \"curvedCW\")) %>%\n  visNodes(label = nodes_df$label, title = nodes_df$label) %>%\n  visOptions(highlightNearest = list(enabled = TRUE, hover = TRUE),\n             nodesIdSelection = TRUE,\n             selectedBy = \"label\") %>%\n  visInteraction(hover = TRUE) %>%\n  visNodes(id = top_twenty_nodes$id, borderWidth = 3, color = list(border = \"red\")) %>%\n  visNodes(id = setdiff(nodes_df$id, top_twenty_nodes$id), color = list(border = \"gray\"))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "title": "Take-home_Ex03",
    "section": "",
    "text": "The code chunk below will be used to install and load the necessary R packages to meet the data preparation, data wrangling, data analysis and visualisation needs.\n\npacman::p_load(jsonlite, tidygraph, ggraph, \n               visNetwork, graphlayouts, ggforce, \n               skimr, tidytext, tidyverse, caret)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-import",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-import",
    "title": "Take-home_Ex03",
    "section": "Data Import",
    "text": "Data Import\nIn the code chunk below, fromJSON() of jsonlite package is used to import MC3.json into R environment.\n\nmc3_data <- fromJSON(\"data/MC3.json\")\n\nThe output is called mc3_data. It is a large list R object.\n\nExtracting edges\nThe code chunk below will be used to extract the links data.frame of mc3_data and save it as a tibble data.frame called mc3_edges.\n\nmc3_edges <- as_tibble(mc3_data$links) %>% \n  distinct() %>%\n  mutate(source = as.character(source),\n         target = as.character(target),\n         type = as.character(type)) %>%\n  group_by(source, target, type) %>%\n    summarise(weights = n()) %>%\n  filter(source!=target) %>%\n  ungroup()\n\n`summarise()` has grouped output by 'source', 'target'. You can override using\nthe `.groups` argument.\n\n\n\n\nExtracting nodes\nThe code chunk below will be used to extract the nodes data.frame of mc3_data and save it as a tibble data.frame called mc3_nodes.\n\nmc3_nodes <- as_tibble(mc3_data$nodes) %>%\n  mutate(country = as.character(country),\n         id = as.character(id),\n         product_services = as.character(product_services),\n         revenue_omu = as.numeric(as.character(revenue_omu)),\n         type = as.character(type)) %>%\n  select(id, country, type, revenue_omu, product_services)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `revenue_omu = as.numeric(as.character(revenue_omu))`.\nCaused by warning:\n! NAs introduced by coercion"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-data-exploration",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-data-exploration",
    "title": "Take-home_Ex03",
    "section": "Initial Data Exploration",
    "text": "Initial Data Exploration\n\nExploring the edges data frame\nIn the code chunk below, skim() of skimr package is used to display the summary statistics of mc3_edges tibble data frame.\n\nskim(mc3_edges)\n\n\nData summary\n\n\nName\nmc3_edges\n\n\nNumber of rows\n24036\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n3\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsource\n0\n1\n6\n700\n0\n12856\n0\n\n\ntarget\n0\n1\n6\n28\n0\n21265\n0\n\n\ntype\n0\n1\n16\n16\n0\n2\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nweights\n0\n1\n1\n0\n1\n1\n1\n1\n1\n▁▁▇▁▁\n\n\n\n\n\nThe report above reveals that there is not missing values in all fields.\nIn the code chunk below, datatable() of DT package is used to display mc3_edges tibble data frame as an interactive table on the html document.\n\nDT::datatable(mc3_edges)\n\nWarning in instance$preRenderHook(instance): It seems your data is too\nbig for client-side DataTables. You may consider server-side processing:\nhttps://rstudio.github.io/DT/server.html\n\n\n\n\n\n\n\n\nggplot(data = mc3_edges,\n       aes(x = type)) +\n  geom_bar()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-network-visualisation-and-analysis",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-network-visualisation-and-analysis",
    "title": "Take-home_Ex03",
    "section": "Initial Network Visualisation and Analysis",
    "text": "Initial Network Visualisation and Analysis\n\nBuilding network model with tidygraph\n\nid1 <- mc3_edges %>%\n  select(source) %>%\n  rename(id = source)\nid2 <- mc3_edges %>%\n  select(target) %>%\n  rename(id = target)\nmc3_nodes1 <- rbind(id1, id2) %>%\n  distinct() %>%\n  left_join(mc3_nodes,\n            unmatched = \"drop\")\n\nJoining with `by = join_by(id)`\n\n\n\nmc3_graph <- tbl_graph(nodes = mc3_nodes1,\n                       edges = mc3_edges,\n                       directed = FALSE) %>%\n  mutate(betweenness_centrality = centrality_betweenness(),\n         closeness_centrality = centrality_closeness())\n\n\nmc3_graph %>%\n  filter(betweenness_centrality >= 100000) %>%\nggraph(layout = \"fr\") +\n  geom_edge_link(aes(alpha=0.5)) +\n  geom_node_point(aes(\n    size = betweenness_centrality,\n    colors = \"lightblue\",\n    alpha = 0.5)) +\n  scale_size_continuous(range=c(1,10))+\n  theme_graph()\n\nWarning in geom_node_point(aes(size = betweenness_centrality, colors =\n\"lightblue\", : Ignoring unknown aesthetics: colours\n\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#exploring-the-nodes-data-frame",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#exploring-the-nodes-data-frame",
    "title": "Take-home_Ex03",
    "section": "Exploring the nodes data frame",
    "text": "Exploring the nodes data frame\nIn the code chunk below, skim() of skimr package is used to display the summary statistics of mc3_nodes tibble data frame.\n\nskim(mc3_nodes)\n\n\nData summary\n\n\nName\nmc3_nodes\n\n\nNumber of rows\n27622\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n4\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nid\n0\n1\n6\n64\n0\n22929\n0\n\n\ncountry\n0\n1\n2\n15\n0\n100\n0\n\n\ntype\n0\n1\n7\n16\n0\n3\n0\n\n\nproduct_services\n0\n1\n4\n1737\n0\n3244\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nrevenue_omu\n21515\n0.22\n1822155\n18184433\n3652.23\n7676.36\n16210.68\n48327.66\n310612303\n▇▁▁▁▁\n\n\n\n\n\nThe report above reveals that there is no missing values in all fields.\nIn the code chunk below, datatable() of DT package is used to display mc3_nodes tibble data frame as an interactive table on the html document.\n\nDT::datatable(mc3_nodes)\n\nWarning in instance$preRenderHook(instance): It seems your data is too\nbig for client-side DataTables. You may consider server-side processing:\nhttps://rstudio.github.io/DT/server.html\n\n\n\n\n\n\n\n\nggplot(data = mc3_nodes,\n       aes(x = type)) +\n  geom_bar()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-sensing-with-tidytext",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-sensing-with-tidytext",
    "title": "Take-home_Ex03",
    "section": "Text Sensing with tidytext",
    "text": "Text Sensing with tidytext\nIn this section, you will learn how to perform basic text sensing using appropriate functions of tidytext package.\n\nSimple word count\nThe code chunk below calculates number of times the word fish appeared in the field product_services.\n\nmc3_nodes %>% \n    mutate(n_fish = str_count(product_services, \"fish\")) \n\n# A tibble: 27,622 × 6\n   id                          country type  revenue_omu product_services n_fish\n   <chr>                       <chr>   <chr>       <dbl> <chr>             <int>\n 1 Jones LLC                   ZH      Comp…  310612303. Automobiles           0\n 2 Coleman, Hall and Lopez     ZH      Comp…  162734684. Passenger cars,…      0\n 3 Aqua Advancements Sashimi … Oceanus Comp…  115004667. Holding firm wh…      0\n 4 Makumba Ltd. Liability Co   Utopor… Comp…   90986413. Car service, ca…      0\n 5 Taylor, Taylor and Farrell  ZH      Comp…   81466667. Fully electric …      0\n 6 Harmon, Edwards and Bates   ZH      Comp…   75070435. Discount superm…      0\n 7 Punjab s Marine conservati… Riodel… Comp…   72167572. Beef, pork, chi…      0\n 8 Assam   Limited Liability … Utopor… Comp…   72162317. Power and Gas s…      0\n 9 Ianira Starfish Sagl Import Rio Is… Comp…   68832979. Light commercia…      0\n10 Moran, Lewis and Jimenez    ZH      Comp…   65592906. Automobiles, tr…      0\n# ℹ 27,612 more rows\n\n\n\n\nTokenisation\nThe word tokenisation have different meaning in different scientific domains. In text sensing, tokenisation is the process of breaking up a given text into units called tokens. Tokens can be individual words, phrases or even whole sentences. In the process of tokenisation, some characters like punctuation marks may be discarded. The tokens usually become the input for the processes like parsing and text mining.\nIn the code chunk below, unnest_token() of tidytext is used to split text in product_services field into words.\n\ntoken_nodes <- mc3_nodes %>%\n  unnest_tokens(word, \n                product_services)\n\nThe two basic arguments to unnest_tokens() used here are column names. First we have the output column name that will be created as the text is unnested into it (word, in this case), and then the input column that the text comes from (product_services, in this case).\nNow we can visualise the words extracted by using the code chunk below.\n\ntoken_nodes %>%\n  count(word, sort = TRUE) %>%\n  top_n(15) %>%\n  mutate(word = reorder(word, n)) %>%\n  ggplot(aes(x = word, y = n)) +\n  geom_col() +\n  xlab(NULL) +\n  coord_flip() +\n      labs(x = \"Count\",\n      y = \"Unique words\",\n      title = \"Count of unique words found in product_services field\")\n\nSelecting by n\n\n\n\n\n\nThe bar chart reveals that the unique words contains some words that may not be useful to use. For instance “a” and “to”. In the word of text mining we call those words stop words. You want to remove these words from your analysis as they are fillers used to compose a sentence.\n\n\nRemoving stopwords\nLucky for use, the tidytext package has a function called stop_words that will help us clean up stop words.\nLet’s give this a try next!\n\nstopwords_removed <- token_nodes %>% \n  anti_join(stop_words)\n\nJoining with `by = join_by(word)`\n\n\nNow we can visualise the words extracted by using the code chunk below.\n\nstopwords_removed %>%\n  count(word, sort = TRUE) %>%\n  top_n(15) %>%\n  mutate(word = reorder(word, n)) %>%\n  ggplot(aes(x = word, y = n)) +\n  geom_col() +\n  xlab(NULL) +\n  coord_flip() +\n      labs(x = \"Count\",\n      y = \"Unique words\",\n      title = \"Count of unique words found in product_services field\")\n\nSelecting by n"
  }
]