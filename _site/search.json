[
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "title": "Take-home_Ex02",
    "section": "",
    "text": "pacman::p_load(jsonlite, tidyverse, tidygraph, ggraph, visNetwork, lubridate, igraph, ggplot2, dplyr, magrittr)\n\n\n\n\n\nmc2_data <- fromJSON(\"C:/Fay1109/ISSS608-VAA/Take-home_Ex/Take-home_Ex02/data/mc2_challenge_graph.json\")\n\n\n\n\n\n\nThe code chunk is used to extract nodes/edges data tables from MC2 list object and save the output in a tibble data frame object called MC2_nodes and MC2_edges.\n\nmc2_nodes <- as_tibble(mc2_data$nodes) %>%\n  select(id, shpcountry, rcvcountry)\n\n\nmc2_edges <- as_tibble(mc2_data$links) %>%\n  mutate(ArrivalDate = ymd(arrivaldate)) %>%\n  mutate(Year = year(ArrivalDate)) %>%\n  select(source, target, ArrivalDate, Year, hscode, valueofgoods_omu, \n         volumeteu, weightkg, valueofgoodsusd) %>% \n  distinct()\n\nMap hscode to corresponding fish type.\n\nmc2_edges_mapped <- mc2_edges %>%\n  mutate(fishtype = case_when(\n    startsWith(hscode, \"301\") ~ \"live fish\",\n    startsWith(hscode, \"302\") ~ \"fresh fish\",\n    startsWith(hscode, \"303\") ~ \"frozen fish\",\n    startsWith(hscode, \"304\") ~ \"fish meat\",\n    startsWith(hscode, \"305\") ~ \"processed fish\",\n    startsWith(hscode, \"306\") ~ \"crustaceans\",  #like lobster or shrimps\n    startsWith(hscode, \"307\") ~ \"molluscs\",  #like Oysters or Abalone\n    startsWith(hscode, \"308\") ~ \"aquatic invertebrates\", #like Sea cucumbers?\n    startsWith(hscode, \"309\") ~ \"seafood flours\",  #fish powder, shrimp powder?\n    TRUE ~ \"not fish\"\n  ))\n\nVisualization\nThe graph below shows the number of counts in different fish categories being traded along the time. Fish meat is transported with the most frequent times in each year, followed by crustaceans\n\nlibrary(ggplot2)\n\n# Group the data by fishtype and Year and calculate the count\nfish_counts <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(count = n())\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Plot the graph\nggplot(fish_counts, aes(x = Year, y = count, fill = fishtype)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(x = \"Year\", y = \"Count\", fill = \"Fish Category\") +\n  scale_fill_discrete(name = \"Fish Category\") +\n  scale_y_continuous(labels = function(x) format(x, big.mark = \",\")) +\n  theme_minimal()\n\n\n\n\nThis is the graph showing the distribution of number of companies shipping different types of products. It can be seen that fish meat is shipped by most companies, followed by frozen fish. Live fish and aquatic invertebrates are the least two product categories shipped by companies.\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(magrittr)\n# Filter out the \"not fish\" category\nfiltered_data <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  distinct(source, fishtype)\n\n# Group the data by fishtype and calculate the number of unique companies\nfish_counts <- filtered_data %>%\n  group_by(fishtype) %>%\n  summarise(count = n_distinct(source))\n\n# Plot the bar chart\nggplot(fish_counts, aes(x = fishtype, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(x = \"Fish Type\", y = \"Number of Companies\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\nHere is the line chart to show the changes of shipments in different fish types. It can be seen that live fish and processed fish does not change too much in number of shipments. Fish meat and molluscs have some fluctuations in number of shipments and have a decreasing trend from 2033 to 2034. Frozen fish and crustaceans have an increasing trend in number of shipments.\n\nlibrary(ggplot2)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n# Filter out the \"not fish\" category\nfish_counts <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(total_count = n())\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Plot the line chart\nggplot(fish_counts, aes(x = Year, y = total_count, color = fishtype, group = fishtype)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Number of Shipments\", color = \"Fish Category\") +\n  scale_color_discrete(name = \"Fish Category\") +\n  theme_minimal() +\n  theme(legend.position = \"right\") +\n  scale_y_continuous(labels = comma)\n\n\n\n\nThe line chart below shows the total weight of all categories shipped along these years. It can be seen from the graph that total weights of shipment has an increasing trend from the first year to 2032. Then it has a decreasing trend after 2032. One interesting finding is that most shipment reach the peak value of total weights in quarter 3.\n\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(scales)\nlibrary(plotly)\n\nWarning: package 'plotly' was built under R version 4.2.3\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\n# Convert ArrivalDate to a date object\nmc2_edges_mapped$ArrivalDate <- ymd(mc2_edges_mapped$ArrivalDate)\n\n# Extract Year and Quarter from ArrivalDate\nmc2_edges_mapped$Year <- year(mc2_edges_mapped$ArrivalDate)\nmc2_edges_mapped$Quarter <- quarter(mc2_edges_mapped$ArrivalDate)\n\n# Group the data by Year and Quarter and calculate the total weightkg\nweight_by_quarter <- mc2_edges_mapped %>%\n  group_by(Year, Quarter) %>%\n  summarise(total_weight = sum(weightkg))\n\n`summarise()` has grouped output by 'Year'. You can override using the\n`.groups` argument.\n\n# Create a combined Year-Quarter label\nweight_by_quarter$YearQuarter <- paste(weight_by_quarter$Year, weight_by_quarter$Quarter, sep = \", \")\n\n# Get the unique years\nunique_years <- unique(weight_by_quarter$Year)\n\n# Plot the line graph with modified x-axis labels\np <- ggplot(weight_by_quarter, aes(x = YearQuarter, y = total_weight, group = 1)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Weight (kg)\") +\n  theme_minimal() +\n  scale_x_discrete(labels = function(x) {\n    ifelse(grepl(\", 1\", x), c(gsub(\",.*\", \"\", x), unique_years[match(gsub(\",.*\", \"\", x), unique_years)]), \"\")\n  }, expand = c(0, 0)) +\n  scale_y_continuous(labels = scales::comma, limits = c(0, max(weight_by_quarter$total_weight) * 1.1), expand = c(0, 0))\n\n# Convert the ggplot object to plotly\np <- ggplotly(p, tooltip = c(\"x\", \"y\"))\n\n# Display the interactive plot\np\n\n\n\n\n\nThis is the line showing the change in total weights of shipment in different fish types. The trend of line in each fish type is very similar to the line plotting the number of shipments in each fish type, which is quite reasonable.\n\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(scales)\nlibrary(plotly)\n\n# Convert ArrivalDate to a date object\nmc2_edges_mapped$ArrivalDate <- ymd(mc2_edges_mapped$ArrivalDate)\n\n# Extract Year and Quarter from ArrivalDate\nmc2_edges_mapped$Year <- year(mc2_edges_mapped$ArrivalDate)\nmc2_edges_mapped$Quarter <- quarter(mc2_edges_mapped$ArrivalDate)\n\n# Filter out the \"not fish\" category\nfish_weights <- mc2_edges_mapped %>%\n  filter(fishtype != \"not fish\") %>%\n  group_by(fishtype, Year) %>%\n  summarise(total_weight = sum(weightkg))\n\n`summarise()` has grouped output by 'fishtype'. You can override using the\n`.groups` argument.\n\n# Create a combined Year-Quarter label\nfish_weights$YearQuarter <- paste(fish_weights$Year, fish_weights$Quarter, sep = \", \")\n\nWarning: Unknown or uninitialised column: `Quarter`.\n\n# Plot the line chart\np <- ggplot(fish_weights, aes(x = YearQuarter, y = total_weight, color = fishtype, group = fishtype)) +\n  geom_line() +\n  geom_point() +\n  labs(x = \"Year\", y = \"Total Weight (kg)\", color = \"Fish Category\") +\n  scale_color_discrete(name = \"Fish Category\") +\n  theme_minimal() +\n  theme(legend.position = \"right\") +\n  scale_y_continuous(labels = comma)\n\n# Convert the ggplot object to plotly\np <- ggplotly(p, tooltip = c(\"x\", \"y\"))\n\n# Display the interactive plot\np\n\n\n\n\n\n\nmc2_edges_aggregated <- mc2_edges_mapped %>%\n  filter(fishtype != \"no fish\") %>%\n  mutate(Year = as.character(Year), Quarter = as.character(Quarter)) %>%\n  filter((Year == \"2032\" & Quarter == \"3\") | (Year != \"2032\")) %>%\n  group_by(source, target, fishtype, Year) %>%\n  summarise(weights = n()) %>%\n  filter(source != target) %>%\n  filter(weights > 20) %>%\n  ungroup()\n\n`summarise()` has grouped output by 'source', 'target', 'fishtype'. You can\noverride using the `.groups` argument.\n\n\n\nid1 <- mc2_edges_aggregated %>%\n  select(source) %>%\n  rename(id = source)\nid2 <- mc2_edges_aggregated %>%\n  select(target) %>%\n  rename(id = target)\nmc2_nodes_extracted <- rbind(id1, id2) %>%\n  distinct()\n\n\nmc2_graph <- tbl_graph(nodes = mc2_nodes_extracted,\n                       edges = mc2_edges_aggregated,\n                       directed = TRUE)\n\n\nggraph(mc2_graph,\n       layout = \"fr\") +\n  geom_edge_link(aes()) +\n  geom_node_point(aes()) +\n  theme_graph()\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\nedges_df <- mc2_graph %>%\n  activate(edges) %>%\n  as.tibble()\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\n\n\nwrite_rds(mc2_nodes_extracted, \"data/mc2_nodes_extracted.rds\")\nwrite_rds(mc2_edges_aggregated, \"data/mc2_edges_aggregated.rds\")\nwrite_rds(mc2_graph, \"data/mc2_graph.rds\")\n\n\nmc2_graph\n\n# A tbl_graph: 6664 nodes and 35991 edges\n#\n# A directed multigraph with 104 components\n#\n# A tibble: 6,664 × 1\n  id                                          \n  <chr>                                       \n1 \" Direct Limited Liability Company Shipping\"\n2 \" Direct S.A. de C.V.\"                      \n3 \" Direct Shark Oyj Marine sanctuary\"        \n4 \"-28\"                                       \n5 \"-64\"                                       \n6 \"1 AS Marine sanctuary\"                     \n# ℹ 6,658 more rows\n#\n# A tibble: 35,991 × 5\n   from    to fishtype Year  weights\n  <int> <int> <chr>    <chr>   <int>\n1     1  3848 not fish 2028       25\n2     1  3848 not fish 2029       28\n3     2  3849 not fish 2033       35\n# ℹ 35,988 more rows\n\n\n\nedges_df <- mc2_graph %>%\n  activate(edges) %>%\n  as.tibble()\n\n\nnodes_df <- mc2_graph %>%\n  activate(nodes) %>%\n  as_tibble() %>%\n  rename(label = id) %>%\n  mutate(id = row_number())\n\nThe network below shows the interaction between shipping and receiving countries. The graph represents various nodes (representing entities such as countries or regions) and edges (representing trade connections). visNetwork function is used to create the graph, with the nodes and edges as input. The layout of the graph is determined by the “layout_with_fr” option, which utilizes the Fruchterman-Reingold algorithm. The edges are displayed with curved arrows for visual clarity.\n\nlibrary(visNetwork)\nlibrary(igraph)\n\n# Create the graph from the data frame\ngraph <- graph_from_data_frame(mc2_edges, directed = FALSE)\n\n# Calculate the number of edges for each node (node degrees)\nnode_degrees <- degree(graph)\n\n# Sort the nodes based on the number of edges in descending order\nsorted_nodes <- nodes_df[order(-node_degrees), ]\n\n# Get the top 20 nodes\ntop_twenty_nodes <- sorted_nodes[1:20, ]\n\n# Create the visNetwork graph\nvisNetwork(nodes_df, edges_df, main = \"FishEye Trade Network\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visEdges(arrows = \"to\", smooth = list(enabled = TRUE, type = \"curvedCW\")) %>%\n  visNodes(label = nodes_df$label, title = nodes_df$label) %>%\n  visOptions(highlightNearest = list(enabled = TRUE, hover = TRUE),\n             nodesIdSelection = TRUE,\n             selectedBy = \"label\") %>%\n  visInteraction(hover = TRUE) %>%\n  visNodes(id = top_twenty_nodes$id, borderWidth = 3, color = list(border = \"red\")) %>%\n  visNodes(id = setdiff(nodes_df$id, top_twenty_nodes$id), color = list(border = \"gray\"))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "title": "Take-home_Ex03",
    "section": "",
    "text": "The code chunk below will be used to install and load the necessary R packages to meet the data preparation, data wrangling, data analysis and visualisation needs.\n\npacman::p_load(jsonlite, tidygraph, ggraph, \n               visNetwork, graphlayouts, ggforce, \n               skimr, tidytext, tidyverse, caret, igraph, wordcloud)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-import",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-import",
    "title": "Take-home_Ex03",
    "section": "Data Import",
    "text": "Data Import\nIn the code chunk below, fromJSON() of jsonlite package is used to import MC3.json into R environment.\n\nmc3_data <- fromJSON(\"data/MC3.json\")\n\nThe output is called mc3_data. It is a large list R object.\n\nExtracting edges\nThe code chunk below will be used to extract the links data.frame of mc3_data and save it as a tibble data.frame called mc3_edges.\n\nmc3_edges <- as_tibble(mc3_data$links) %>% \n  distinct() %>%\n  mutate(source = as.character(source),\n         target = as.character(target),\n         type = as.character(type)) %>%\n  group_by(source, target, type) %>%\n    summarise(weights = n()) %>%\n  filter(source!=target) %>%\n  ungroup()\n\n`summarise()` has grouped output by 'source', 'target'. You can override using\nthe `.groups` argument.\n\n\n\n\nExtracting nodes\nThe code chunk below will be used to extract the nodes data.frame of mc3_data and save it as a tibble data.frame called mc3_nodes.\n\nmc3_nodes <- as_tibble(mc3_data$nodes) %>%\n  mutate(country = as.character(country),\n         id = as.character(id),\n         product_services = as.character(product_services),\n         revenue_omu = as.numeric(as.character(revenue_omu)),\n         type = as.character(type)) %>%\n  select(id, country, type, revenue_omu, product_services)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `revenue_omu = as.numeric(as.character(revenue_omu))`.\nCaused by warning:\n! NAs introduced by coercion"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-data-exploration",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-data-exploration",
    "title": "Take-home_Ex03",
    "section": "Initial Data Exploration",
    "text": "Initial Data Exploration\n\nExploring the edges data frame\nIn the code chunk below, skim() of skimr package is used to display the summary statistics of mc3_edges tibble data frame.\n\nskim(mc3_edges)\n\n\nData summary\n\n\nName\nmc3_edges\n\n\nNumber of rows\n24036\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n3\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsource\n0\n1\n6\n700\n0\n12856\n0\n\n\ntarget\n0\n1\n6\n28\n0\n21265\n0\n\n\ntype\n0\n1\n16\n16\n0\n2\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nweights\n0\n1\n1\n0\n1\n1\n1\n1\n1\n▁▁▇▁▁\n\n\n\n\n\nThe report above reveals that there is not missing values in all fields.\nIn the code chunk below, datatable() of DT package is used to display mc3_edges tibble data frame as an interactive table on the html document.\n\nDT::datatable(mc3_edges)\n\nWarning in instance$preRenderHook(instance): It seems your data is too\nbig for client-side DataTables. You may consider server-side processing:\nhttps://rstudio.github.io/DT/server.html"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-network-visualisation-and-analysis",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#initial-network-visualisation-and-analysis",
    "title": "Take-home_Ex03",
    "section": "Initial Network Visualisation and Analysis",
    "text": "Initial Network Visualisation and Analysis\n\nBuilding network model with tidygraph\n\nid1 <- mc3_edges %>%\n  select(source) %>%\n  rename(id = source)\nid2 <- mc3_edges %>%\n  select(target) %>%\n  rename(id = target)\nmc3_nodes1 <- rbind(id1, id2) %>%\n  distinct() %>%\n  left_join(mc3_nodes,\n            unmatched = \"drop\")\n\nJoining with `by = join_by(id)`\n\n\n\nmc3_graph <- tbl_graph(nodes = mc3_nodes1,\n                       edges = mc3_edges,\n                       directed = FALSE) %>%\n  mutate(betweenness_centrality = centrality_betweenness(),\n         closeness_centrality = centrality_closeness())\n\n\nmc3_graph %>%\n  filter(betweenness_centrality >= 100000) %>%\nggraph(layout = \"fr\") +\n  geom_edge_link(aes(alpha=0.5)) +\n  geom_node_point(aes(\n    size = betweenness_centrality,\n    colors = \"lightblue\",\n    alpha = 0.5)) +\n  scale_size_continuous(range=c(1,10))+\n  theme_graph()\n\nWarning in geom_node_point(aes(size = betweenness_centrality, colors =\n\"lightblue\", : Ignoring unknown aesthetics: colours\n\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#exploring-the-nodes-data-frame",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#exploring-the-nodes-data-frame",
    "title": "Take-home_Ex03",
    "section": "Exploring the nodes data frame",
    "text": "Exploring the nodes data frame\nIn the code chunk below, skim() of skimr package is used to display the summary statistics of mc3_nodes tibble data frame.\n\nskim(mc3_nodes)\n\n\nData summary\n\n\nName\nmc3_nodes\n\n\nNumber of rows\n27622\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n4\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nid\n0\n1\n6\n64\n0\n22929\n0\n\n\ncountry\n0\n1\n2\n15\n0\n100\n0\n\n\ntype\n0\n1\n7\n16\n0\n3\n0\n\n\nproduct_services\n0\n1\n4\n1737\n0\n3244\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nrevenue_omu\n21515\n0.22\n1822155\n18184433\n3652.23\n7676.36\n16210.68\n48327.66\n310612303\n▇▁▁▁▁\n\n\n\n\n\nThe report above reveals that there is no missing values in all fields.\nIn the code chunk below, datatable() of DT package is used to display mc3_nodes tibble data frame as an interactive table on the html document.\n\nDT::datatable(mc3_nodes)\n\nWarning in instance$preRenderHook(instance): It seems your data is too\nbig for client-side DataTables. You may consider server-side processing:\nhttps://rstudio.github.io/DT/server.html"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-sensing-with-tidytext",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-sensing-with-tidytext",
    "title": "Take-home_Ex03",
    "section": "Text Sensing with tidytext",
    "text": "Text Sensing with tidytext\nIn this section, you will learn how to perform basic text sensing using appropriate functions of tidytext package.\n\nSimple word count\nThe code chunk below calculates number of times the word fish appeared in the field product_services.\n\nmc3_nodes %>% \n    mutate(n_fish = str_count(product_services, \"fish\")) \n\n# A tibble: 27,622 × 6\n   id                          country type  revenue_omu product_services n_fish\n   <chr>                       <chr>   <chr>       <dbl> <chr>             <int>\n 1 Jones LLC                   ZH      Comp…  310612303. Automobiles           0\n 2 Coleman, Hall and Lopez     ZH      Comp…  162734684. Passenger cars,…      0\n 3 Aqua Advancements Sashimi … Oceanus Comp…  115004667. Holding firm wh…      0\n 4 Makumba Ltd. Liability Co   Utopor… Comp…   90986413. Car service, ca…      0\n 5 Taylor, Taylor and Farrell  ZH      Comp…   81466667. Fully electric …      0\n 6 Harmon, Edwards and Bates   ZH      Comp…   75070435. Discount superm…      0\n 7 Punjab s Marine conservati… Riodel… Comp…   72167572. Beef, pork, chi…      0\n 8 Assam   Limited Liability … Utopor… Comp…   72162317. Power and Gas s…      0\n 9 Ianira Starfish Sagl Import Rio Is… Comp…   68832979. Light commercia…      0\n10 Moran, Lewis and Jimenez    ZH      Comp…   65592906. Automobiles, tr…      0\n# ℹ 27,612 more rows\n\n\n\n\nTokenisation\nThe word tokenisation have different meaning in different scientific domains. In text sensing, tokenisation is the process of breaking up a given text into units called tokens. Tokens can be individual words, phrases or even whole sentences. In the process of tokenisation, some characters like punctuation marks may be discarded. The tokens usually become the input for the processes like parsing and text mining.\nIn the code chunk below, unnest_token() of tidytext is used to split text in product_services field into words.\n\ntoken_nodes <- mc3_nodes %>%\n  unnest_tokens(word, \n                product_services)\n\nThe two basic arguments to unnest_tokens() used here are column names. First we have the output column name that will be created as the text is unnested into it (word, in this case), and then the input column that the text comes from (product_services, in this case).\nNow we can visualise the words extracted by using the code chunk below.\n\ntoken_nodes %>%\n  count(word, sort = TRUE) %>%\n  top_n(15) %>%\n  mutate(word = reorder(word, n)) %>%\n  ggplot(aes(x = word, y = n)) +\n  geom_col() +\n  xlab(NULL) +\n  coord_flip() +\n      labs(x = \"Count\",\n      y = \"Unique words\",\n      title = \"Count of unique words found in product_services field\")\n\nSelecting by n\n\n\n\n\n\nThe bar chart reveals that the unique words contains some words that may not be useful to use. For instance “a” and “to”. In the word of text mining we call those words stop words. You want to remove these words from your analysis as they are fillers used to compose a sentence.\n\n\nRemoving stopwords\nLucky for use, the tidytext package has a function called stop_words that will help us clean up stop words.\nLet’s give this a try next!\n\nstopwords_removed <- token_nodes %>% \n  anti_join(stop_words)\n\nJoining with `by = join_by(word)`\n\n\nNow we can visualise the words extracted by using the code chunk below.\n\nstopwords_removed %>%\n  count(word, sort = TRUE) %>%\n  top_n(15) %>%\n  mutate(word = reorder(word, n)) %>%\n  ggplot(aes(x = word, y = n)) +\n  geom_col() +\n  xlab(NULL) +\n  coord_flip() +\n      labs(x = \"Count\",\n      y = \"Unique words\",\n      title = \"Count of unique words found in product_services field\")\n\nSelecting by n"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "City of Engagement, with a total population of 50,000, is a small city located at Country of Nowhere. The city serves as a service centre of an agriculture region surrounding the city. The main agriculture of the region is fruit farms and vineyards. The local council of the city is in the process of preparing the Local Plan 2023. A sample survey of 1000 representative residents had been conducted to collect data related to their household demographic and spending patterns, among other things. The city aims to use the data to assist with their major community revitalization efforts, including how to allocate a very large city renewal grant they have recently received."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-age",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-age",
    "title": "Take-home_Ex01",
    "section": "Distribution of Age",
    "text": "Distribution of Age\nThe distribution of age shows that the number of people under 20 is less than other groups.\nFor people in other four groups, the numbers of people are similar.\n\n# Create age groups\nparticipants <- participants %>%\n  mutate(age_group = cut(age, breaks = c(0, 20, 30, 40, 50, 60, Inf),\n                         labels = c(\"0-20\", \"20-30\", \"30-40\", \"40-50\", \"50-60\", \"60+\"),\n                         include.lowest = TRUE))\n\n# Distribution of Age\nggplot(data = participants, aes(x = age_group)) +\n  geom_bar(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Age Group\", y = \"Count\") +\n  ggtitle(\"Distribution of Age\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-education-level",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-education-level",
    "title": "Take-home_Ex01",
    "section": "Distribution of Education Level",
    "text": "Distribution of Education Level\nThe distribution of educationLevel shows that the number of people with HighSchoolor College degree is the highest, followed by Bachelors degree. The number of people with Low degree is the lowest.\n\n# Distribution of EducationLevel\nggplot(data = participants, aes(x = educationLevel)) +\n  geom_bar(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Education Level\", y = \"Count\") +\n  ggtitle(\"Distribution of Education Level\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-interest-group",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-interest-group",
    "title": "Take-home_Ex01",
    "section": "Distribution of interest group",
    "text": "Distribution of interest group\nThe distribution of interest group shows that group J is the most popular one within the population.\n\n# Distribution of InterestGroup\nggplot(data = participants, aes(x = interestGroup)) +\n  geom_bar(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Interest Group\", y = \"Count\") +\n  ggtitle(\"Distribution of Interest Group\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-expense-under-each-category",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-expense-under-each-category",
    "title": "Take-home_Ex01",
    "section": "Distribution of expense under each category",
    "text": "Distribution of expense under each category\nCalculate the sum of expense under each category including food, shelter, recreation and education.\n\n# Filter the financial journal for each category and calculate the sum of expenses\nfood_expenses <- financial_journal %>%\n  filter(category == \"Food\") %>%\n  summarise(total_amount = sum(amount))\n\nshelter_expenses <- financial_journal %>%\n  filter(category == \"Shelter\") %>%\n  summarise(total_amount = sum(amount))\n\nrecreation_expenses <- financial_journal %>%\n  filter(category == \"Recreation\") %>%\n  summarise(total_amount = sum(amount))\n\neducation_expenses <- financial_journal %>%\n  filter(category == \"Education\") %>%\n  summarise(total_amount = sum(amount))\n\n# Print the results\nprint(food_expenses)\n\n# A tibble: 1 × 1\n  total_amount\n         <dbl>\n1     3703421.\n\nprint(shelter_expenses)\n\n# A tibble: 1 × 1\n  total_amount\n         <dbl>\n1     6776049.\n\nprint(recreation_expenses)\n\n# A tibble: 1 × 1\n  total_amount\n         <dbl>\n1     4143338.\n\nprint(education_expenses)\n\n# A tibble: 1 × 1\n  total_amount\n         <dbl>\n1      140012.\n\n\nIt can be seen that the expense spent on shelter is the largest among total expense and the expense on education is the least.\n\n# Create a data frame with category and total amount\nexpenses <- data.frame(\n  Category = c(\"Food\", \"Shelter\", \"Recreation\", \"Education\"),\n  TotalAmount = c(food_expenses$total_amount, shelter_expenses$total_amount,\n                  recreation_expenses$total_amount, education_expenses$total_amount)\n)\n\n# Create the bar plot\nggplot(data = expenses, aes(x = Category, y = TotalAmount)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(x = \"Expense Category\", y = \"Total Amount\", title = \"Distribution of Expense Categories\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-total-expense-by-month",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#distribution-of-total-expense-by-month",
    "title": "Take-home_Ex01",
    "section": "Distribution of total expense by month",
    "text": "Distribution of total expense by month\nCalculate the total expense spent by population of each month.\nPlot line chart to show changes across time. It can be seen that the expense reach the highest level in March.\n\nlibrary(lubridate)\n\n# Convert the timestamp column to date format\nfinancial_journal$timestamp <- as.Date(financial_journal$timestamp)\n\n# Extract the month from the timestamp column\nfinancial_journal$month <- month(financial_journal$timestamp)\n\n# Group the financial_journal data by month and category, and calculate the sum of amount\nmonthly_expenses <- financial_journal %>%\n  group_by(month, category) %>%\n  summarize(total_amount = sum(amount))\n\n# Filter the expenses for the four categories\nfiltered_expenses <- monthly_expenses %>%\n  filter(category %in% c(\"Food\", \"Shelter\", \"Recreation\", \"Education\"))\n\n# Sum the expenses by month\nsum_by_month <- filtered_expenses %>%\n  group_by(month) %>%\n  summarize(total_expenses = sum(total_amount))\n\n# Print the resulting data frame\nprint(sum_by_month)\n\n# A tibble: 12 × 2\n   month total_expenses\n   <dbl>          <dbl>\n 1     1       1194726.\n 2     2       1123479.\n 3     3       1623411.\n 4     4       1265334.\n 5     5       1219848.\n 6     6       1187592.\n 7     7       1213307.\n 8     8       1189678.\n 9     9       1174663.\n10    10       1210174.\n11    11       1161012.\n12    12       1199598.\n\n# Plot the line graph\nggplot(sum_by_month, aes(x = month, y = total_expenses, group = 1)) +\n  geom_line() +\n  labs(x = \"Month\", y = \"Total Expenses\", title = \"Sum of Expenses by Month\") +\n  scale_x_continuous(breaks = 1:12, labels = month.abb) +\n  theme_minimal()\n\n\n\n\nCalculate each participant’s wage expense, shelter expense, education expense and recreation expense.\n\n# Calculate the sum of wage group by participantID\nwage_sum <- financial_journal %>%\n  filter(category == \"Wage\") %>%\n  group_by(participantId) %>%\n  summarize(total_wage = sum(amount))\n\n\n# Calculate the sum of shelter group by participantID\nshelter_sum <- financial_journal %>%\n  filter(category == \"Shelter\") %>%\n  group_by(participantId) %>%\n  summarize(total_Shelter = sum(amount))\n\n\n# Calculate the sum of education group by participantID\neducation_sum <- financial_journal %>%\n  filter(category == \"Education\") %>%\n  group_by(participantId) %>%\n  summarize(total_education = sum(amount))\n\n\n# Calculate the sum of food group by participantID\nfood_sum <- financial_journal %>%\n  filter(category == \"Food\") %>%\n  group_by(participantId) %>%\n  summarize(total_food = sum(amount))\n\n\n# Calculate the sum of recreation group by participantID\nrecreation_sum <- financial_journal %>%\n  filter(category == \"Recreation\") %>%\n  group_by(participantId) %>%\n  summarize(total_recreation = sum(amount))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#relationship-between-expense-on-education-and-wage",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#relationship-between-expense-on-education-and-wage",
    "title": "Take-home_Ex01",
    "section": "Relationship between expense on education and wage",
    "text": "Relationship between expense on education and wage\nExplore the relationship between expense on education and wage.\n\ncosts <- merge(education_sum, wage_sum, by = \"participantId\")\n\nThe correlation analysis between total_education and total_wage variables resulted in a Pearson’s product-moment correlation coefficient of 0.2687. This coefficient indicates a positive correlation between the two variables.\nThe test statistic (t-value) is 4.8227 with degrees of freedom (df) equal to 299. The p-value associated with the test statistic is 2.259e-06, which is very small. This low p-value suggests strong evidence against the null hypothesis of no correlation, indicating that there is a significant correlation between total_education and total_wage.\nThe 95% confidence interval for the correlation coefficient ranges from 0.1605 to 0.3705. This interval provides an estimated range within which the true correlation between the variables is likely to fall.\nIn conclusion, based on this analysis, there is a statistically significant positive correlation (0.2687) between the total education expenses and total wage amounts.\n\ncorrelation_test <- cor.test(costs$total_education, costs$total_wage)\nprint(correlation_test)\n\n\n    Pearson's product-moment correlation\n\ndata:  costs$total_education and costs$total_wage\nt = 4.8227, df = 299, p-value = 2.259e-06\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.1604738 0.3704532\nsample estimates:\n      cor \n0.2686522 \n\n\nThe R-squared value of 0.07 indicates that approximately 7% of the variance in the wage variable can be explained by the linear relationship with the education variable. This means that the education level alone explains a small portion of the variation in wages.\nThe equation “wage = 27.88 * education + 36404.3” represents the estimated linear relationship between the education level and wages. The coefficient 27.88 indicates that, on average, for every unit increase in the education level, the wage is expected to increase by approximately 27.88 units.\n\nscatter_plot <- ggplot(costs, aes(x = total_education, y = total_wage)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"blue\") +\n  xlab(\"Total Education Cost\") +\n  ylab(\"Total Wage Cost\") +\n  ggtitle(\"Relationship between Education Cost and Wage Cost\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n# Calculate coefficients of the linear regression model\nlm_model <- lm(total_wage ~ total_education, data = costs)\nintercept <- coef(lm_model)[1]\nslope <- coef(lm_model)[2]\n\n# Create the equation string\nequation <- paste0(\"Wage = \", round(slope, 2), \" * Education + \", round(intercept, 2))\n\n# Calculate R-squared value\nr_squared <- round(summary(lm_model)$r.squared, 2)\n\n# Add equation and R-squared as text annotations\nscatter_plot <- scatter_plot +\n  geom_text(x = max(costs$total_education), y = max(costs$total_wage), label = equation, hjust = 1, vjust = 1, color = \"black\") +\n  geom_text(x = max(costs$total_education), y = max(costs$total_wage), label = paste0(\"R-squared = \", r_squared), hjust = 1, vjust = 0, color = \"black\")\n\nprint(scatter_plot)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-age-and-joviality.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-age-and-joviality.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between age and joviality.",
    "text": "Explore the relationship between age and joviality.\nFirst, divide population into five groups. Then calculate the average joviality of each group.\nIt can be seen from the graph that people in group 4 whose age falls between 45 to 55 have the lowest level of joviality.\n\n# Categorize participants into age groups\nparticipants <- participants %>%\n  mutate(age_group = cut(age, breaks = c(0, 25, 35, 45, 55, Inf),\n                         labels = c(\"Group 1\", \"Group 2\", \"Group 3\", \"Group 4\", \"Group 5\"),\n                         include.lowest = TRUE))\n\n# Calculate average joviality for each age group\navg_joviality <- participants %>%\n  group_by(age_group) %>%\n  summarise(avg_joviality = mean(joviality, na.rm = TRUE))\n\n# Print the average joviality by age group\nprint(avg_joviality)\n\n# A tibble: 5 × 2\n  age_group avg_joviality\n  <fct>             <dbl>\n1 Group 1           0.512\n2 Group 2           0.514\n3 Group 3           0.507\n4 Group 4           0.444\n5 Group 5           0.499\n\n\n\n# Create bar chart\nbar_chart <- ggplot(avg_joviality, aes(x = age_group, y = avg_joviality)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Age Group\", y = \"Average Joviality\", title = \"Average Joviality by Age Group (Bar Chart)\")\n\n# Create line graph\nline_graph <- ggplot(avg_joviality, aes(x = as.numeric(age_group), y = avg_joviality)) +\n  geom_line(color = \"black\", size = 1) +\n  labs(x = \"Age Group\", y = \"Average Joviality\", title = \"Average Joviality by Age Group (Line Graph)\")\n\n# Combine bar chart and line graph\ncombined_plot <- bar_chart +\n  geom_line(data = avg_joviality, aes(x = as.numeric(age_group), y = avg_joviality), color = \"black\", size = 1) +\n  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())\n\n# Display the combined plot\nprint(combined_plot)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-joviality-and-havekids.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-joviality-and-havekids.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between joviality and havekids.",
    "text": "Explore the relationship between joviality and havekids.\nIt can be seen from the boxplot that there is not too much difference between these two groups.\nThe median of joviality of people who have children is slightly higher than group who do not have children.\n\n# Create a box plot of joviality by haveKids\nggplot(data = participants, aes(x = haveKids, y = joviality)) +\n  geom_boxplot(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Have Kids\", y = \"Joviality\") +\n  ggtitle(\"Distribution of Joviality by Have Kids\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-household-size-and-shelter-expense.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-household-size-and-shelter-expense.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between household size and shelter expense.",
    "text": "Explore the relationship between household size and shelter expense.\nFrom the boxplot we can see that the shelter expense does not exhibit a positive relationship with household size. Household size 2 has the highest median expense while the expense on household size 3 has the highest ceiling expense which is reasonable.\n\n# Merge the shelter sum data with participants data\nshelter_data <- merge(participants, shelter_sum, by = \"participantId\", all.x = TRUE)\n\n# Create box plot\nbox_plot <- ggplot(shelter_data, aes(x = as.factor(householdSize), y = total_Shelter)) +\n  geom_boxplot(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Household Size\", y = \"Expense on Shelter\", title = \"Relationship between Household Size and Shelter Expense\") +\n  theme_minimal()\n\n# Display the box plot\nprint(box_plot)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-wage-and-education-level.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-wage-and-education-level.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between wage and education level.",
    "text": "Explore the relationship between wage and education level.\nFrom the graph it can be seen that people with higher education level have higher wage level.\nPeople with graduate degree earn the most and people with low degree earn the least.\n\n# Merge participants data with wage_sum data\nmerged_data <- merge(participants, wage_sum, by = \"participantId\", all.x = TRUE)\n\n# Create a scatter plot\nggplot(data = merged_data, aes(x = educationLevel, y = total_wage)) +\n  geom_point() +\n  labs(x = \"Education Level\", y = \"Total Wage\") +\n  ggtitle(\"Relationship between Education Level and Total Wage\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-wage-and-interest-group.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-wage-and-interest-group.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between wage and interest group.",
    "text": "Explore the relationship between wage and interest group.\nFrom the graph it can be seen that there is not too much difference in wage between different groups. The median wage of different interest group is similar.\n\n# Wage and Interest Group\n# Merge wage_sum with participants data\nmerged_data <- merge(participants, wage_sum, by = \"participantId\")\n\n# Create a box plot\nggplot(data = merged_data, aes(x = interestGroup, y = total_wage)) +\n  geom_boxplot(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Interest Group\", y = \"Total Wage\") +\n  ggtitle(\"Relationship between Wage and Interest Group\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-age-and-wage.",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#explore-the-relationship-between-age-and-wage.",
    "title": "Take-home_Ex01",
    "section": "Explore the relationship between age and wage.",
    "text": "Explore the relationship between age and wage.\nFrom the boxplot it can be seen that there is not too much difference in median of wage across different age groups. While people in the first group and the last group have the highest ceiling wage.\n\n# Define age ranges\nage_ranges <- c(\"0-25\", \"26-35\", \"36-45\", \"46-55\", \"56+\")\n\n# Categorize participants into age groups:\nparticipants <- participants %>%\n  mutate(age_group = cut(age, breaks = c(0, 25, 35, 45, 55, Inf),\n                         labels = age_ranges,\n                         include.lowest = TRUE))\n\n# Merge wage_sum with participants data\nmerged_data <- merge(participants, wage_sum, by = \"participantId\")\n\n# Create a box plot\nggplot(data = merged_data, aes(x = age_group, y = total_wage)) +\n  geom_boxplot(fill = \"steelblue\", color = \"black\") +\n  labs(x = \"Age Range\", y = \"Total Wage\") +\n  ggtitle(\"Relationship between Age Range and Wage\")\n\n\n\n\nCalculate the average wage of each age group.\n\n# Calculate average wage for each age group\navg_wage <- merged_data %>%\n  group_by(age_group) %>%\n  summarize(avg_wage = mean(total_wage))\n\n# Print the average wage by age group\nprint(avg_wage)\n\n# A tibble: 5 × 2\n  age_group avg_wage\n  <fct>        <dbl>\n1 0-25        46863.\n2 26-35       44279.\n3 36-45       45936.\n4 46-55       44407.\n5 56+         43845.\n\n\nThe linear regression analysis examined the association between joviality and total wage among the participants. The results revealed a statistically significant relationship between the two variables as the p-value is extremely small. The estimated intercept, representing the joviality when the total wage is zero, was found to be 0.6497. Additionally, the coefficient for the total wage variable was -3.456e-06, indicating that for each unit increase in total wage, the joviality is expected to decrease by 3.456e-06 units, holding other variables constant. The model showed that approximately 13.15% of the variability in joviality can be explained by the linear relationship with total wage, as indicated by the R-squared value. The statistical significance of the F-statistic further supported the overall significance of the model. It shows that the joviality decreases when wage increases.\n\n# Merge participants data with wage_sum data\nmerged_data <- merge(participants, wage_sum, by = \"participantId\", all.x = TRUE)\n\n# Perform linear regression\nlm_model <- lm(joviality ~ total_wage, data = merged_data)\n\n# Print the regression summary\nsummary(lm_model)\n\n\nCall:\nlm(formula = joviality ~ total_wage, data = merged_data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.62577 -0.22125  0.00418  0.20937  0.60214 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  6.497e-01  1.523e-02   42.65   <2e-16 ***\ntotal_wage  -3.456e-06  2.796e-07  -12.36   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2717 on 1009 degrees of freedom\nMultiple R-squared:  0.1315,    Adjusted R-squared:  0.1306 \nF-statistic: 152.8 on 1 and 1009 DF,  p-value: < 2.2e-16\n\n\n\n# Create a scatter plot with linear regression line\nggplot(data = merged_data, aes(x = total_wage, y = joviality)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(x = \"Total Wage\", y = \"Joviality\") +\n  ggtitle(\"Linear Regression: Joviality and Total Wage\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#joviality-age-and-total-wage",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#joviality-age-and-total-wage",
    "title": "Take-home_Ex01",
    "section": "Joviality, Age and Total Wage",
    "text": "Joviality, Age and Total Wage\nCluster 1 has an average joviality of 0.4753, indicating a moderate level of joviality. The average age in this cluster is 51.36533, suggesting that the participants in this group are relatively older. The average total wage for this cluster is 37112.00, which indicates a moderate level of income.\nCluster 2 exhibits a higher average joviality of 0.7306, indicating a higher level of joviality compared to the other clusters. The average age in this cluster is 29.85511, suggesting that the participants in this group are relatively younger. The average total wage for this cluster is 30882.44, indicating a moderate level of income.\nCluster 3 has a lower average joviality of 0.2247, indicating a relatively lower level of joviality. The average age in this cluster is 34.27113, indicating participants of varying ages. Interestingly, this cluster has the highest average total wage of 73274.87, suggesting a relatively higher income level.\n\n# Merge participants and wage_sum datasets\nmerged_data <- merge(participants, wage_sum, by = \"participantId\", all.x = TRUE)\n\n# Select the variables for clustering\ndata <- merged_data[, c(\"joviality\", \"age\", \"total_wage\")]\n\n# Standardize the variables (optional)\ndata <- scale(data)\n\n# Determine the number of clusters (k)\nk <- 3\n\n# Apply k-means clustering\nkmeans_result <- kmeans(data, centers = k)\n\n# Extract the cluster assignments\ncluster_assignments <- kmeans_result$cluster\n\n# Print the cluster assignments\nprint(cluster_assignments)\n\n\n# Add cluster assignments to the merged_data dataframe\nmerged_data$cluster <- cluster_assignments\n\n# Calculate the average values by cluster\ncluster_summary <- merged_data %>%\n  group_by(cluster) %>%\n  summarise(avg_joviality = mean(joviality),\n            avg_age = mean(age),\n            avg_total_wage = mean(total_wage))\n\n# Print the cluster summary\nprint(cluster_summary)\n\n# A tibble: 3 × 4\n  cluster avg_joviality avg_age avg_total_wage\n    <int>         <dbl>   <dbl>          <dbl>\n1       1         0.514    51.4         35223.\n2       2         0.219    35.5         71897.\n3       3         0.719    28.9         31786.\n\n\n\n# Add cluster assignments to the merged_data dataframe\nmerged_data$cluster <- cluster_assignments\n\n# Create scatter plots\nggplot(merged_data, aes(x = age, y = total_wage, color = factor(cluster))) +\n  geom_point() +\n  labs(x = \"Age\", y = \"Total Wage\", color = \"Cluster\") +\n  ggtitle(\"Cluster Analysis: Age vs Total Wage\")\n\n\n\nggplot(merged_data, aes(x = joviality, y = total_wage, color = factor(cluster))) +\n  geom_point() +\n  labs(x = \"Joviality\", y = \"Total Wage\", color = \"Cluster\") +\n  ggtitle(\"Cluster Analysis: Joviality vs Total Wage\")\n\n\n\n\n\nlibrary(GGally)\n\n# Select the variables of interest\ncluster_vars <- merged_data[, c(\"joviality\", \"age\", \"total_wage\", \"cluster\")]\n\n# Create parallel coordinate plot\nggparcoord(cluster_vars, columns = 1:3, groupColumn = \"cluster\", alphaLines = 0.6) +\n  labs(x = \"Variable\", y = \"Value\", color = \"Cluster\") +\n  ggtitle(\"Cluster Analysis: Parallel Coordinate Plot\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#distribution-analysis",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#distribution-analysis",
    "title": "Take-home_Ex03",
    "section": "Distribution Analysis",
    "text": "Distribution Analysis\nHere is the distribution of two different types in edges.\n\nggplot(data = mc3_edges,\n       aes(x = type)) +\n  geom_bar() +\n  labs(title = \"Type variable in Edges\")  # Add the plot title\n\n\n\n\nHere is the distribution of three different types in nodes.\n\nggplot(data = mc3_nodes,\n       aes(x = type)) +\n  geom_bar() +\n  labs(title = \"Type variable in Nodes\")  # Add the plot title\n\n\n\n\nHere is the boxplot graph of revenue distribution across nodes type.\nAs can be seen from the graph, “Benefical Owner” has the highest median of revenue. “Company” has lots of outliers but with the lowest median of revenue. For “Company Contracts”, this category has the least variation, with the median value at around 100,000.\n\nggplot(data = mc3_nodes, aes(x = type, y = revenue_omu)) +\n  geom_boxplot() +\n  scale_y_log10() +  # Apply logarithmic scale to the y-axis\n  ylab(\"Revenue\") +\n  ggtitle(\"Distribution of Revenue by Node Type\")\n\nWarning: Removed 21515 rows containing non-finite values (`stat_boxplot()`)."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-visualization",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#text-visualization",
    "title": "Take-home_Ex03",
    "section": "Text Visualization",
    "text": "Text Visualization\nThis part use wordcloud library is called with the filtered words and their frequencies. The words are extracted from “product_services” to find which type of products and services are the most transported among all the goods categories. As can be seen from the graph, the words that appear at a high frequency are: fish, seafood, frozen, salmon and fresh.\n\nlibrary(tidytext)\nlibrary(wordcloud)\n\n# Create a tidy text data frame from the product_services column\ntidy_data <- mc3_nodes %>%\n  select(product_services) %>%\n  unnest_tokens(word, product_services)\n\n# Load the stopwords dataset\ndata(stop_words)\n\n# Filter out stopwords and common meaningless words\nfiltered_data <- tidy_data %>%\n  anti_join(stop_words) %>%\n  filter(!word %in% c(\"0\", \"other\", \"as\", \"a\", \"such\", \"for\", \"as\", \"the\", \"related\", \"unknown\", \"character\"))\n\nJoining with `by = join_by(word)`\n\n# Compute word frequencies\nword_freq <- filtered_data %>%\n  count(word)\n\n# Filter words based on frequency\nmin_freq <- 10\nmax_words <- 200\nfiltered_words <- word_freq %>%\n  filter(n >= min_freq) %>%\n  top_n(max_words, wt = n) %>%\n  pull(word)\n\n# Generate the word cloud\nword_freq_filtered <- word_freq %>%\n  filter(word %in% filtered_words)\n\n# Define colors for the word cloud (darker colors)\ncolors <- brewer.pal(length(filtered_words), \"Dark2\")\n\nWarning in brewer.pal(length(filtered_words), \"Dark2\"): n too large, allowed maximum for palette Dark2 is 8\nReturning the palette you asked for with that many colors\n\nwordcloud(\n  words = word_freq_filtered$word,\n  freq = word_freq_filtered$n,\n  colors = colors\n)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#network-visualization",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#network-visualization",
    "title": "Take-home_Ex03",
    "section": "Network Visualization",
    "text": "Network Visualization\nThe following network graph shows the nodes and edges that the centrality_betweenness score is larger than 100,000 and degree is above 3.\n\nlibrary(igraph)\nlibrary(visNetwork)\n\n# Convert the edges graph to a tibble\nedges_df <- mc3_graph %>%\n  activate(edges) %>%\n  as_tibble()\n\n# Convert the nodes graph to a tibble\nnodes_df <- mc3_graph %>%\n  activate(nodes) %>%\n  as_tibble() %>%\n  rename(label = id) %>%\n  mutate(id = row_number()) %>%\n  select(id, label)\n\n# Perform community detection using the Louvain algorithm on the graph\ncommunities <- cluster_louvain(mc3_graph)\n\n# Get the cluster membership of each node\nmembership <- membership(communities)\n\n# Add the cluster membership information to the nodes data frame\nnodes_df$group <- membership\n\n\nmc3_graph <- tbl_graph(nodes = mc3_nodes1,\n                       edges = mc3_edges,\n                       directed = FALSE) %>%\nmutate(betweenness_centrality = centrality_betweenness(),\n       closeness_centrality = as.factor(centrality_closeness())) %>%\nfilter(betweenness_centrality >= 100000)\n\n         \n# Calculate the degrees of each node\ndegrees <- degree(mc3_graph)\nset.seed (1234)\n\nmc3_graph %>%\n  # filter(betweenness_centrality >= 100000) %>%\n  ggraph(layout = \"fr\") +\n  geom_edge_link(aes(alpha = 0.5)) +\n  geom_node_point(aes(size = betweenness_centrality,\n                      color = closeness_centrality,\n                      alpha = 0.5), show.legend = FALSE) +\n  geom_node_text(aes(label = ifelse(degrees > 3, as.character(id), \"\")), size = 2) +  # Add node labels\n  scale_size_continuous(range = c(1, 10)) +\n  labs(title = \"Network Visualization\") +  # Add the plot title\n  theme_graph()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\nThis code plots the graph of network visualization to show the nodes and edges of “beneficial owner” and “company”.\n\nlibrary(ggraph)\n\nmc3_graph %>%\n  filter(betweenness_centrality >= 1000000) %>%\n  ggraph(layout = \"fr\") +\n  geom_edge_link(aes(alpha = 0.5)) +\n  geom_node_point(aes(\n    size = betweenness_centrality,\n    color = type,\n    shape = type),\n    alpha = 0.8) +\n  scale_size_continuous(range = c(1, 6)) +\n  scale_color_manual(values = c(\"Company Contacts\" = \"yellow\", \"Beneficial Owner\" = \"red\", \"Company\" = \"blue\")) +\n  scale_shape_manual(values = c(\"Company Contacts\" = 17, \"Beneficial Owner\" = 15, \"Company\" = 16)) +\n  theme_graph() +\n  labs(title = \"Network Visualization\") +\n  theme(plot.title = element_text(hjust = 0.5))\n\nWarning: Removed 34 rows containing missing values (`geom_point()`).\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\nGroup Detection\n\nedges_df <- mc3_graph %>%\n  activate(edges) %>%\n  as.tibble()\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\nnodes_df <- mc3_graph %>%\n  activate(nodes) %>%\n  as.tibble() %>%\n  rename(label = id) %>%\n  mutate(id=row_number()) %>%\n  select(id, label)\n\n# Perform community detection using the cluster edge betweenness\ncommunities <- cluster_edge_betweenness(mc3_graph)\n\n# Get the cluster membership of each node\nmembership <- membership(communities)\n\n# Add the cluster membership information to the nodes data frame\nnodes_df$group <- membership\n\n# Plot the graph with clustered nodes using visNetwork\nvisNetwork(nodes_df, edges_df) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visEdges(arrows = \"to\",\n           smooth = list(enabled = TRUE,\n                         type = \"curvedCW\"), \n           color = list(highlight = \"lightgray\")) %>%\n  visOptions(highlightNearest = list(enabled = TRUE,\n                                     degree = 1,\n                                     hover = TRUE,\n                                     labelOnly = TRUE),\n             nodesIdSelection = TRUE,\n             selectedBy = \"group\") %>%\n  visLayout(randomSeed = 1234)"
  }
]